
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FlowFate AI Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex justify-center items-center min-h-screen p-4">

  <!-- Mobile-Responsive Chat UI -->
  <div class="w-full max-w-md bg-white rounded-3xl shadow-lg p-6 flex flex-col gap-4 h-[90vh]">

    <!-- Header -->
    <div class="flex items-center gap-2">
      <div class="bg-gray-100 p-2 rounded-full">
        <img src="https://cdn-icons-png.flaticon.com/512/906/906349.png" class="h-6 w-6" alt="AI Icon" />
      </div>
      <span class="text-lg font-semibold">FlowFate AI</span>
      <div class="relative ml-auto">
        <button id="profileBtn" class="bg-gray-200 text-xs w-8 h-8 rounded-full flex items-center justify-center font-medium focus:outline-none focus:ring-2 focus:ring-blue-400 transition-shadow" title="User Menu">
          <span>M</span>
        </button>
        <div id="profileDropdown" class="hidden absolute right-0 mt-2 w-36 bg-white rounded-xl shadow-lg border border-gray-100 z-20 py-2">
          <a href="dashboard.html" class="block px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-t-xl">Dashboard</a>
          <button id="logoutBtn" class="w-full text-left px-4 py-2 text-red-600 hover:bg-gray-100 rounded-b-xl">Logout</button>
        </div>
      </div>
  </div>



  <!-- Compact Icon Controls -->
  <div class="flex justify-end gap-2 mb-1">
    <button id="autoScrollToggle" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 transition-colors flex items-center justify-center" title="Toggle Auto-Scroll">
      <svg id="autoScrollIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1.5" fill="#22c55e" id="autoScrollOnCircle" />
        <path d="M8 12l2 2 4-4" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" id="autoScrollOnCheck" />
      </svg>
      <span class="sr-only">Toggle Auto-Scroll</span>
    </button>
    <button id="clearChatBtn" class="p-2 rounded-full bg-red-100 hover:bg-red-200 text-red-600 transition-colors flex items-center justify-center" title="Clear Chat">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
      </svg>
      <span class="sr-only">Clear Chat</span>
    </button>
  </div>

    <!-- Chat Section -->
    <!-- Small Discord-like Chat Icon as background, with centered empty message below -->
    <div class="relative flex-1 flex flex-col">
      <div id="chatBgIcon" class="absolute left-0 right-0 top-4 flex justify-center pointer-events-none z-0 transition-opacity duration-700 opacity-40">
        <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-indigo-100 text-indigo-600 shadow" title="Chat Icon">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 3C7.03 3 3 6.58 3 11.01c0 2.13 1.06 4.07 2.82 5.5-.13.98-.56 2.36-1.7 3.13 0 0-.03.02-.03.04 0 .09.07.16.16.16.02 0 .04 0 .06-.01 1.38-.18 2.44-.95 3.13-1.5.97.28 2.01.44 3.13.44 4.97 0 9-3.58 9-8.01S16.97 3 12 3z" />
          </svg>
        </span>
      </div>
      <div id="chatBox" class="flex flex-1 flex-col gap-4 mt-4 text-sm overflow-y-auto relative z-10">
        <div class="flex flex-col items-center justify-center mt-12 mb-2" id="emptyChatMsg">
          <p class="text-base">Start a new conversation</p>
          <p class="text-xs">How can FlowFate AI assist you today?</p>
        </div>
      <!-- Typing/Loading Indicator -->
      <div id="typingIndicator" class="text-center text-xs text-gray-500 mt-2 hidden flex-col items-center justify-center">
        <span class="inline-flex items-center gap-2 justify-center">
          <svg class="animate-spin h-4 w-4 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8z"></path>
          </svg>
          FlowFate AI is typing...
        </span>
      </div>
    </div>

    <!-- Help Icon above input, right-aligned -->
    <div class="flex justify-end mb-1">
      <!-- Notion Quick Actions -->
      <div class="flex gap-2 mb-2">
        <button id="createNotionPageBtn" class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 text-black hover:bg-green-100 transition-colors" title="Create Notion Page">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <rect x="4" y="4" width="16" height="16" rx="3" stroke="currentColor" stroke-width="1.5" fill="#fff" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v8m-4-4h8" stroke="#22c55e" stroke-width="1.5" />
          </svg>
          <span class="sr-only">Create Notion Page</span>
        </button>
        <button id="showNotionFeedBtn" class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 text-indigo-600 hover:bg-indigo-200 transition-colors" title="Show Recent Notion Updates">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <rect x="4" y="4" width="16" height="16" rx="3" stroke="currentColor" stroke-width="1.5" fill="#fff" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M8 8h8M8 12h8M8 16h4" stroke="#6366f1" stroke-width="1.5" />
          </svg>
          <span class="sr-only">Show Notion Feed</span>
        </button>
      </div>
      <a href="help.html" class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 text-blue-500 hover:bg-blue-100 transition-colors" title="Help">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 18h.01M12 14.25V12a2.25 2.25 0 10-2.25-2.25" />
          <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" />
        </svg>
        <span class="sr-only">Help</span>
      </a>
    </div>

    <!-- Input Section with File Upload Icon -->
    <div class="mt-auto">
      <div class="flex items-center border rounded-xl overflow-hidden">
        <input type="text" placeholder="Reply to FlowFate AI" class="flex-1 px-4 py-3 text-sm outline-none" id="userInput" />
        <label for="fileInput" class="cursor-pointer px-2 flex items-center h-full" title="Attach file">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-500 hover:text-blue-500 transition-colors">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0013.5 3h-3A2.25 2.25 0 008.25 5.25V19.5a3.75 3.75 0 007.5 0V7.5a.75.75 0 00-1.5 0v12a2.25 2.25 0 11-4.5 0V5.25" />
          </svg>
          <span class="sr-only">Attach file</span>
        </label>
        <input type="file" id="fileInput" class="hidden" title="Choose a file to upload" />
        <button class="px-4 text-blue-500 font-semibold" onclick="handleUserInput()">➤</button>
      </div>
    </div>
  </div>

  <script>
    // Notion: Quick Page Creation
    document.getElementById('createNotionPageBtn').addEventListener('click', async () => {
      appendMessage('Creating a new Notion page...', 'system');
      try {
        const response = await fetch('https://flowfate-ai.onrender.com/api/notion/create-page', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        if (!response.ok) throw new Error('API error');
        const data = await response.json();
        if (data && data.url) {
          appendMessage(`✅ Notion page created: <a href="${data.url}" target="_blank" class="text-blue-500 underline">Open Page</a>`, 'system');
        } else {
          appendMessage('⚠️ Notion page created, but no URL returned.', 'system');
        }
      } catch (err) {
        appendMessage('❌ Failed to create Notion page.', 'system');
      }
    });

    // Notion: Database Query via chat command
    async function handleNotionQuery(queryText) {
      appendMessage('Querying Notion database...', 'system');
      try {
        const response = await fetch('https://flowfate-ai.onrender.com/api/notion/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: queryText })
        });
        if (!response.ok) throw new Error('API error');
        const data = await response.json();
        if (data && data.results && data.results.length > 0) {
          let html = '<ul class="list-disc ml-6">';
          data.results.forEach(item => {
            html += `<li>${item}</li>`;
          });
          html += '</ul>';
          appendMessage(html, 'system');
        } else {
          appendMessage('No results found in Notion database.', 'system');
        }
      } catch (err) {
        appendMessage('❌ Failed to query Notion database.', 'system');
      }
    }

    // Notion: Task/Reminder Creation via chat command
    async function handleNotionTaskOrReminder(text) {
      appendMessage('Creating Notion task/reminder...', 'system');
      try {
        const response = await fetch('https://flowfate-ai.onrender.com/api/notion/create-task', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        if (!response.ok) throw new Error('API error');
        const data = await response.json();
        if (data && data.url) {
          appendMessage(`✅ Notion task/reminder created: <a href="${data.url}" target="_blank" class="text-blue-500 underline">Open Task</a>`, 'system');
        } else {
          appendMessage('⚠️ Notion task/reminder created, but no URL returned.', 'system');
        }
      } catch (err) {
        appendMessage('❌ Failed to create Notion task/reminder.', 'system');
      }
    }

    // Notion: Recent Updates Feed (sidebar or chat command)
    async function showNotionFeed() {
      appendMessage('Fetching recent Notion updates...', 'system');
      try {
        const response = await fetch('https://flowfate-ai.onrender.com/api/notion/recent', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        if (!response.ok) throw new Error('API error');
        const data = await response.json();
        if (data && data.updates && data.updates.length > 0) {
          let html = '<div class="text-left"><b>Recent Notion Updates:</b><ul class="list-disc ml-6">';
          data.updates.forEach(item => {
            html += `<li><a href="${item.url}" target="_blank" class="text-blue-500 underline">${item.title || 'Untitled'}</a> <span class="text-xs text-gray-400">${item.time || ''}</span></li>`;
          });
          html += '</ul></div>';
          appendMessage(html, 'system');
        } else {
          appendMessage('No recent Notion updates found.', 'system');
        }
      } catch (err) {
        appendMessage('❌ Failed to fetch Notion updates.', 'system');
      }
    }

    // Notion: Link unfurling in chat (detect Notion links and show preview)
    async function unfurlNotionLinksInMessage(msgDiv) {
      const notionUrlRegex = /https?:\/\/(www\.)?notion\.so\/[\w\-?=&#%]+/g;
      const links = msgDiv.innerHTML.match(notionUrlRegex);
      if (links) {
        for (const url of links) {
          try {
            const response = await fetch('https://flowfate-ai.onrender.com/api/notion/unfurl', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url })
            });
            if (!response.ok) continue;
            const data = await response.json();
            if (data && data.title) {
              // Insert preview below the link
              const preview = document.createElement('div');
              preview.className = 'bg-gray-50 border border-gray-200 rounded p-2 mt-1 text-xs text-left';
              preview.innerHTML = `<b>${data.title}</b><br>${data.snippet || ''}`;
              // Find the link in the message and insert after
              const linkEls = msgDiv.querySelectorAll('a');
              for (const a of linkEls) {
                if (a.href.startsWith(url)) {
                  a.parentNode.insertBefore(preview, a.nextSibling);
                }
              }
            }
          } catch {}
        }
      }
    }
    // Persistent chat history helpers
    function saveChatHistory() {
      const messages = Array.from(chatBox.querySelectorAll('.message')).map(msg => ({
        html: msg.outerHTML
      }));
      localStorage.setItem('flowfate_chat_history', JSON.stringify(messages));
    }

    function loadChatHistory() {
      const history = localStorage.getItem('flowfate_chat_history');
      if (history) {
        chatBox.innerHTML = '';
        const messages = JSON.parse(history);
        messages.forEach(m => {
          const temp = document.createElement('div');
          temp.innerHTML = m.html;
          chatBox.appendChild(temp.firstChild);
        });
      }
    }

    // Show/hide typing indicator
    function showTypingIndicator(show) {
      const typing = document.getElementById('typingIndicator');
      if (typing) typing.classList.toggle('hidden', !show);
    }
    // Profile dropdown logic
    const profileBtn = document.getElementById('profileBtn');
    const profileDropdown = document.getElementById('profileDropdown');
    let dropdownOpen = false;
    profileBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdownOpen = !dropdownOpen;
      profileDropdown.classList.toggle('hidden', !dropdownOpen);
    });
    // Close dropdown if clicking outside
    document.addEventListener('click', (e) => {
      if (dropdownOpen && !profileBtn.contains(e.target) && !profileDropdown.contains(e.target)) {
        profileDropdown.classList.add('hidden');
        dropdownOpen = false;
      }
    });
    // Logout button logic
    document.getElementById('logoutBtn').addEventListener('click', () => {
      // Simple logout: redirect to login.html (or implement your own logic)
      window.location.href = 'login.html';
    });
    function updateChatBgIconVisibility() {
      const chatBgIcon = document.getElementById('chatBgIcon');
      // If chat is empty (only emptyChatMsg present), show faded icon; else, fade out
      if (chatBox.children.length === 1 && chatBox.contains(emptyChatMsg)) {
        chatBgIcon.style.opacity = '0.4';
        chatBgIcon.style.pointerEvents = 'none';
      } else {
        chatBgIcon.style.opacity = '0';
        chatBgIcon.style.pointerEvents = 'none';
      }
    }

    function appendMessage(text, sender = 'user') {
      // Remove empty message if present
      if (emptyChatMsg && emptyChatMsg.parentNode === chatBox) {
        chatBox.removeChild(emptyChatMsg);
      }
      const msg = document.createElement('div');
      // WhatsApp iOS-like colors
      let bgClass = '';
      let alignClass = '';
      if (sender === 'user') {
        bgClass = 'bg-green-100 text-gray-900'; // light green bubble
        alignClass = 'self-end';
      } else if (sender === 'bot') {
        bgClass = 'bg-white text-gray-900 border border-gray-200'; // white bubble
        alignClass = 'self-start';
      } else if (sender === 'system') {
        bgClass = 'bg-yellow-50 text-yellow-800 border border-yellow-200'; // light yellow for system
        alignClass = 'self-center';
      }
      msg.className = `${alignClass} message ${sender} ${bgClass} text-sm p-2 my-1 rounded-xl max-w-xs shadow`;
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      // If bot and text is HTML, strip tags and decode entities, then clean up whitespace
      let displayText = text;
      if (sender === 'bot' && /^<div/i.test(text.trim())) {
        const temp = document.createElement('div');
        temp.innerHTML = text;
        displayText = temp.textContent || temp.innerText || '';
        // Clean up: collapse multiple spaces/newlines, trim
        displayText = displayText.replace(/\s+/g, ' ').replace(/ +/g, ' ').trim();
      }

      msg.innerHTML = `<div>${displayText}</div><div class="text-xs text-right opacity-60">${time}</div>`;
      chatBox.appendChild(msg);
      // Notion link unfurling (only for user and bot messages)
      if (sender === 'user' || sender === 'bot') {
        setTimeout(() => unfurlNotionLinksInMessage(msg), 0);
      }
      if (autoScrollEnabled) scrollChatToBottom();
      saveChatHistory();
      updateChatBgIconVisibility();
    }
    const fileInput = document.getElementById('fileInput');

    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (file) {
        // Remove empty message if present
        if (emptyChatMsg && emptyChatMsg.parentNode === chatBox) {
          chatBox.removeChild(emptyChatMsg);
        }
        const fileMessage = document.createElement('div');
        fileMessage.className = 'self-end message file bg-blue-100 p-2 rounded my-2 max-w-xs';
        fileMessage.innerHTML = `📎 <strong>${file.name}</strong> (${Math.round(file.size / 1024)} KB)`;
        chatBox.appendChild(fileMessage);
        scrollChatToBottom();
      }
    });
    let autoScrollEnabled = true;

    const autoScrollToggle = document.getElementById('autoScrollToggle');
    const chatBox = document.getElementById('chatBox');
    const clearChatBtn = document.getElementById('clearChatBtn');
    const emptyChatMsg = document.getElementById('emptyChatMsg');

    const autoScrollIcon = document.getElementById('autoScrollIcon');
    const autoScrollOnCircle = document.getElementById('autoScrollOnCircle');
    const autoScrollOnCheck = document.getElementById('autoScrollOnCheck');
    autoScrollToggle.addEventListener('click', () => {
      autoScrollEnabled = !autoScrollEnabled;
      // Change icon color for ON/OFF
      if (autoScrollEnabled) {
        autoScrollOnCircle.setAttribute('fill', '#22c55e'); // green
        autoScrollOnCheck.setAttribute('stroke', '#fff');
      } else {
        autoScrollOnCircle.setAttribute('fill', '#ef4444'); // red
        autoScrollOnCheck.setAttribute('stroke', '#fff');
      }
    });

    clearChatBtn.addEventListener('click', () => {
      chatBox.innerHTML = '';
      // Restore empty message prompt after clearing
      if (emptyChatMsg) {
        chatBox.appendChild(emptyChatMsg);
      }
      updateChatBgIconVisibility();
    });

    function scrollChatToBottom() {
      if (autoScrollEnabled) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    }

    async function sendMessage(text) {
      appendMessage(text, 'user');
      showTypingIndicator(true);
      try {
        const response = await fetch('https://flowfate-ai.onrender.com/api/openai', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ prompt: text })
        });
        if (!response.ok) {
          throw new Error('API error');
        }
        const data = await response.json();
        // The backend returns data.data.reply
        if (data && data.data && data.data.reply) {
          appendMessage(data.data.reply, 'bot');
        } else {
          appendMessage('⚠️ No response from AI.', 'system');
        }
      } catch (err) {
        appendMessage('❌ Failed to get response from AI.', 'system');
      } finally {
        showTypingIndicator(false);
      }
    }

    // simulateResponseWithRetry removed: now handled by backend

    function handleUserInput() {
      const input = document.getElementById('userInput');
      const value = input.value.trim();
      if (value !== "") {
        // Notion database query command: /notion-query ...
        if (value.toLowerCase().startsWith('/notion-query')) {
          const queryText = value.replace('/notion-query', '').trim();
          if (queryText) {
            handleNotionQuery(queryText);
          } else {
            appendMessage('Please provide a query after /notion-query', 'system');
          }
        // Notion recent updates feed: /notion-feed
        } else if (value.toLowerCase().startsWith('/notion-feed')) {
          showNotionFeed();
        // Notion task/reminder creation: /notion-task ... or /remind ...
        } else if (value.toLowerCase().startsWith('/notion-task')) {
          const taskText = value.replace('/notion-task', '').trim();
          if (taskText) {
            handleNotionTaskOrReminder(taskText);
          } else {
            appendMessage('Please provide a task/reminder after /notion-task', 'system');
          }
        } else if (value.toLowerCase().startsWith('/remind')) {
          // e.g. /remind me to call John tomorrow
          const taskText = value.replace('/remind', '').trim();
          if (taskText) {
            handleNotionTaskOrReminder(taskText);
          } else {
            appendMessage('Please provide a reminder after /remind', 'system');
          }
        } else {
          sendMessage(value);
        }
        input.value = "";
      }
    }

    // Keyboard shortcuts: Enter to send, Shift+Enter for newline
    document.getElementById('userInput').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleUserInput();
      }
    });

    // Notion feed sidebar button
    document.getElementById('showNotionFeedBtn').addEventListener('click', showNotionFeed);

    // Load chat history on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadChatHistory();
      updateChatBgIconVisibility();
    });
  </script>

</body>
</html>


